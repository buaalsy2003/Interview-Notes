## KMP详解

KMP 算法是一种改进的字符串匹配算法，全称是 Knuth-Morris-Pratt 子串查找算法。KMP 算法的关键在于利用匹配失败后的信息，尽量减少模式串与主串匹配次数，以达到快速匹配的目的。具体上就是实现一个 `next()` 函数，函数本身包含模式串的局部匹配信息。
- 时间复杂度：$O(m+n)$

### 1.暴力匹配法
问题：有一个文本串 S, 和一个模式串 P， 想要查找 P 在 S 中的位置。
如果采用暴力匹配的思路，假设现在文本串 S 匹配到 i 位置，模式串 P 匹配到 j 位置，有：
- 如果当前字符匹配成功 （即 S[i] == P[j]），则 i++, j++，继续匹配下一个字符。
- 如果匹配失败 (即 S[i] != P[j])，令 i = i - (j - 1), j = 0。相当于回溯重来。
```c++
int violentMatch(string& s, string& p)
{
    int sl = s.length();
    int pl = p.length();
    int i = 0, j = 0;
    while (i < sl && j < pl)
    {
        if (s[i] == p[j]) { // successful
            i++;
            j++;
        }
        else { // fail
            i = i - j + 1;
            j = 0;
        }
    }
    if (j == pl)
        return i - j;
    else
        return -1;
}
```
- 时间复杂度：$O(m*n)$
- KMP 的初衷是，在匹配失败时，只移动 j，而不回退 i。

### KMP 算法
#### 算法过程
假设现在文本串 S 匹配到 i 位置，模式串 P 匹配到 j 位置，KMP过程表示为：
- 如果 j = -1，或者当前字符串匹配成功 （即 S[i] == P[j]），都令 i++, j++，继续匹配下一个字符；
- 如果 j != -1，并且当前字符串匹配失败 （即 S[i] != P[j]），都令 i 不变，j=next[j]。此举意味着匹配失败后，模式串 P 相对于文本串 S 向右移动了 j-next[j] 位。
```c++
int KMPSearch(string& s, string& p)
{
    int sl = s.length();
    int pl = p.length();
    int i = 0, j = 0;
    while (i < sl && j < pl)
    {
        if (j == -1 || s[i] == p[j]) { // successful
            i++;
            j++;
        }
        else { // fail
            j = next[j];
        }
    }
    if (j == pl)
        return i - j;
    else
        return -1;
}
```
#### 求解步骤
1. 寻找前缀后缀最长公共元素长度
- 对于 $P_j=P_0P_1...P_{j-1}$，寻找模式串 Pj 中长度最大且相等的前缀和后缀。
 - 即寻找满足条件的最大的 k，使得 $P_0P_1...P_{k-1}=P_{j-k}P_{j-k+1}...P+{j-1}$。也就是说，k 是模式串中各个子串的前缀后缀的公共元素的长度，所以求得最大的 k，就是看某个子串的哪个前缀后缀的公共元素最多。
 - 举个例子，如果给定的模式串为 "abaabcaba"，那么它的各个子串的前缀后缀的公共元素的最大长度值如下表格所示:
    |  模式串  | a | b | a | a | b | c | a | b | a |
    | :-----: | - | - | - | - | - | - | - | - | - |
    | 前缀后缀 | 0 | 0 | 1 | 1 | 2 | 0 | 1 | 2 | 3 |

2. 求 next 数组
 - 根据步骤1中求得的各个前缀后缀的公共元素的最大长度求得next数组，相当于前者右移一位且初值赋为-1，如下表格所示：
    | 模式串 | a | b | a | a | b | c | a | b | a |
    | :---: | - | - | - | - | - | - | - | - | - |
    | next  | -1 | 0 | 0 | 1 | 1 | 2 | 0 | 1 | 2 |

3. 匹配失败且 j != -1时，模式串向右移动的位数为：j-next[j]。
 - 根据《最大长度表》，匹配失败时，模式串向右移动的位数 = 已经匹配的字符数 - 匹配失败字符的上一位字符的最大长度值。
 - 根据《next数组》，匹配失败时，模式串向右移动的位数 = 匹配失败字符所在位置 - 匹配失败字符对应next值。

#### 求解 next 数组
```c++
vector<int> getNext(string p)
{
    int pl = p.length();
    vector<int> next(pl);
    next[0] = -1;
    int k = -1, j = 0;
    while (j < pl -1)
    {
        // p[k] 表示前缀，p[j] 表示后缀
        if (k == -1 || p[j] == p[k]) {
            j++;
            k++;
            next[j] = k;
        }
        else
            k = next[k];
    }
    return next;
}
```
